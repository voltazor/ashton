#!/usr/bin/env python3

import os
import sys
import time
import json
import shlex
import argparse
import datetime
from threading import Thread
from subprocess import run, check_output, CalledProcessError, STDOUT, PIPE
from http.server import HTTPServer, BaseHTTPRequestHandler


parser = argparse.ArgumentParser()
parser.add_argument('-c', '--command', dest='command', type=str, help='Command that should be executed on hook', required=True)
parser.add_argument('-p', '--port', dest='port', type=int, help='Port to listen for incoming hooks', default=3000)
parser.add_argument('--silent', dest='silent', help='Service will produce no logs', default=False, action='store_true')
parser.add_argument('--detailed-logs', dest='detailed_logs', help='Service will produce detailed logs', default=False, action='store_true')
parser.description = 'Listens a specified port for POST requests to catch webhooks from Docker Hub. A valid webhook will trigger the execution of a specified command.' 

if (len(sys.argv) <= 1):
    parser.print_help()
    exit(1)
else:
    args = parser.parse_args()

class HTTPRequestHandler(BaseHTTPRequestHandler):
    def do_POST(self):
        try:
            real_ip = self.headers.get('X-Real-IP')
            client_address = real_ip if real_ip != None else ('%s:%i' % (self.client_address[0], self.client_address[1]))
            if (self.path != '/'):
                raise Exception('Invalid request: %s [%s]' % (self.path, client_address))
            
            logWithTime('Received request [%s]' % (client_address))

            if (args.detailed_logs):
                print('\n%s [%s]' % (self.requestline, self.log_date_time_string()), flush=True)
                print(self.headers, flush=True)

            conent_length = int(self.headers.get('Content-Length'))
            body = self.rfile.read(conent_length).decode('utf-8')
                
            if (args.detailed_logs):
                print(body, flush=True)
                print(flush=True)
            self.respondSuccess()

            request = json.loads(body)
            callback_url = request['callback_url']

            logWithTime('Callback URL found. Processing..')
            Thread(target=handleRequest, args=(callback_url,)).start()    
                
        except Exception as e:
            logWithTime(repr(e))
            print('---', flush=True)
            self.respondFailure()

    def respondSuccess(self):
        self.send_response(200)
        self.send_header('Content-Type', 'application/json')
        self.end_headers()
        self.wfile.write(b'{\n\t"result": "OK"\n}')

    def respondFailure(self):
        self.send_response(500)
        self.send_header('Content-Type', 'application/json')
        self.end_headers()

    def log_message(self, format: str, *args):
        ...

def logWithTime(message=str):
    current_time = time.strftime("%H:%M:%S", time.localtime())
    print('%s %s  %s' % (datetime.date.today(), current_time, message), flush=True)

def handleRequest(callback_url:str):
    callback_call = 'curl --silent -f %s' % callback_url
    if (systemCall(callback_call, with_ouput = args.detailed_logs)):
        logWithTime('Callback [%s] sent' % callback_url)
    else:
        logWithTime('Callback [%s] failed' % callback_url)

    logWithTime('Executing command..')
    if (systemCall(args.command, with_ouput = args.detailed_logs)):
        logWithTime('Command done')
    else:
        logWithTime('Command failed')
    print('---', flush=True)

def systemCall(command=str, with_ouput:bool = True):
    try:
        output = check_output(shlex.split(command), stderr=STDOUT)
        if (with_ouput):
            print()
            print(output.decode('utf-8'), flush=True)
        success = True 
    except CalledProcessError as e:
        print(repr(e), flush=True)
        success = False
    return success

def gracefull_KeyboardInterrupt():
    def graceFullShutdown():
        print()
        print('\r' '\033[2K' '\033[A', end='', flush=True)
        logWithTime('Shutting down..\n')
        exit(0)
    sys.excepthook = lambda type, value, traceback: (
        graceFullShutdown()
        if issubclass(type, KeyboardInterrupt)
        else None
    )

def main():
    gracefull_KeyboardInterrupt()
    if (args.silent):
        so = open(os.devnull, 'w')
        se = open(os.devnull, 'w')
        os.dup2(so.fileno(), sys.stdout.fileno())
        os.dup2(se.fileno(), sys.stderr.fileno())

    try:
        httpd = HTTPServer(("", args.port), HTTPRequestHandler)
        print('--------------------', flush=True)
        print('Serving at port', args.port, flush=True)
        print('--------------------', flush=True)
        httpd.serve_forever()
    except Exception as e:
        print(repr(e), flush=True)

main()
